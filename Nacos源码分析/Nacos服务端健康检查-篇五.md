# NacosæœåŠ¡ç«¯å¥åº·æ£€æŸ¥-ç¯‡äº”

### ğŸ•[Nacos å®¢æˆ·ç«¯æœåŠ¡æ³¨å†Œæºç åˆ†æ-ç¯‡ä¸€](http://124.221.240.218:8080/archives/nacos-ke-hu-duan-fu-wu-zhu-ce-yuan-ma-fen-xi-pian-yi)

### ğŸ•‘[Nacos å®¢æˆ·ç«¯æœåŠ¡æ³¨å†Œæºç åˆ†æ-ç¯‡äºŒ](http://124.221.240.218:8080/archives/nacos-ke-hu-duan-fu-wu-zhu-ce-yuan-ma-pian-er)

### ğŸ•’[Nacos å®¢æˆ·ç«¯æœåŠ¡æ³¨å†Œæºç åˆ†æ-ç¯‡ä¸‰](http://124.221.240.218:8080/archives/nacoske-hu-duan-shi-li-zhu-ce-yuan-ma-fen-xi-pian-san)

### ğŸ•“[Nacos æœåŠ¡ç«¯æœåŠ¡æ³¨å†Œæºç åˆ†æ-ç¯‡å››](http://124.221.240.218:8080/archives/nacosfu-wu-duan-fu-wu-zhu-ce-yuan-ma-fen-xi---pian-si)

------

ä¸Šç¯‡åˆ†ælæœåŠ¡ç«¯çš„æ³¨å†ŒæœåŠ¡çš„æ•´ä¸ªæµç¨‹ï¼Œæ¢ç©¶äº†å¦‚ä½•å°†å®¢æˆ·ç«¯çš„å®ä¾‹ä¿¡æ¯æ³¨å†Œå˜ä¸º Client æ¨¡å‹å®ä½“ï¼Œå®ŒæˆæœåŠ¡ç«¯ Service ä¸ å®¢æˆ·ç«¯æ¨¡å‹ Client ä»¥åŠå®ä¾‹ä¿¡æ¯ instance ä¸‰ä¸ªä¹‹é—´çš„å…³è”çš„ï¼Œ[**åŸå›¾ç‚¹è¿™é‡Œ**](https://viewer.diagrams.net/?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1&title=Nacos_%E6%9C%8D%E5%8A%A1%E7%AB%AF_%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio#R7V1tl6I4Fv41nNPzoeoQwutHteyd3u3u7TN1zszOR1RK2UFwkeqqml%2B%2FCSQIIWhUSHyhes%2BORoKY3Dy5ee6TGw1O1u%2F%2FSP3N6luyCCLN0BfvGnzSDANano3%2Bg0s%2BihIDGGZRskzDRVEGdgXP4d8BKdRJ6Wu4CLa1C7MkibJwUy%2BcJ3EczLNamZ%2BmyVv9spckqn%2Frxl8GjYLnuR81S%2F8IF9mqKHUNZ1f%2BaxAuV%2FSbge0Vn6x9ejH5JduVv0jeKkVwqsFJmiRZ8Wr9Pgki3Hq0XYp6n1s%2BLR8sDeJMpEKwspf%2FtmFofwTxdwP8mP3zy%2FSB3GWbfdAfHCzQ7ydvkzRbJcsk9qPprnScJq%2FxIsB3Bejd7pqvSbIhhf8NsuyDdKb%2FmiWoaJWtI%2FJp8B5m%2F0Gv9UeLvPuz8skTNh6dvvmgb%2BIs%2FahUwm%2F%2FrH62q5a%2Fo%2FWK34d%2FVGuz0TZIXtN5sKetDGJ%2BfroMsj3XwbJz0bAIknWAngfVS4PIz8Kf9efwiXkuy%2Bt2PYhekE48okPJQ%2F70o1fyTZphR%2Bhxx7NaP9v%2Fe03y0iRdBOnDPImSVIOjvGr66eGhWv5L3o60Bnq1JP%2FN7%2FuSoIbEAzC%2Fw1P1QmjY%2BF%2B1qNNH%2BO7Pky26XpvamjfR3CdtamnuSBsBbepoo7E2%2BkyfEjVm8aD1h0fFs10ZMxTqhv62CrPgeePnNvKG4K5u1C9hFE3KNoALK3AXJipfpv4iRLZW%2BcxzFrrjoM%2B2WZr8FVQ%2BcY0ZtG38CQULUD7YzyDNgvf9Vty0OlLhAViuW1T6oCXAJMj0tgM227OKslUF1KDVk7FaStGngj07JOKjT4coAgVRxFSJIvCeUORLvM38eI7GIZo5kigKUvSJv8bjO55tN3W06BdEOhnpUNeZka47zZEOqF9SG%2Bl6TwYFnFt3NDiI3QlemIJ4AWyVgGHeN2B8%2BkUZZDB%2Bx4vuQ93n%2BRbjJ0fXddJylXI9%2F%2BvF5zBtBok8lwNEtkwgMi5oxVNiT98%2Bhy2KIZ7SpYvHARH5fdUXkIt2gqHU87PvCchDAuTPQfoznAe%2FG8pQ28L%2FeKht53%2F8deQs%2FycHuV2oGrkpI3id8HBw2J%2FrvpGqP5IwH0671YDL9KRjMT1UIBepyHRS%2BSRnrCV5lJT8fusQyV3BLoUto0zSGp6ziMc82VRzTW3qacguRgVzZmtjD78YQw3TPwTu0xLpMKnmal7%2BYjzWxiP8YjTFt8IffdZcdGdTG0%2FyG6IS9Cmf2vnqz4Ko3i9%2BFC5j9HqOugGtvOEYI1c496MR%2BWAdLhaFCQTb8G9%2Flt8PO0gbbLF5q1ljzXpqGEkrEJJYAbmVVjL0VVvYY8rtsKk%2FGlZtsJEvPHsQ127q1usnLy%2FboJeR696TL0AXdf%2FeBKmfJekkwrPtl%2FUmkuYU9DCNO3V7fHB4TJAndQHG8zCvejoAooEhtZ49fcxKw6fBMtwi1KW2r00%2FYxRHYE9eeI2u2b6F68iPAzJYaS9hPJ6vwmjx1f9IXnEjoDvO%2F6LvxqskDf9G1%2FulraPWykjvQL12xTOuSe6ZY37wg%2FYKYIq%2B%2Be%2B1C7%2F624w%2BTRJF%2FmYbFiCPK65R%2F4TxOMmyZE0uOs5L13UP%2FYnPM8eMVNtgqRLeSDU5IxWA3jzu9jBAEvU0A0Rhv1PLObfW8T0etrnR4uuAvnnf%2B51dT5Oxvw622Fq%2FLPizz6GJCrfu0N7Cv2Vb8ALfUbMP7S2hvSkf01Vjo0IMVC2%2BGYLrvJNrlEucFHNbBflJEV2oRMFLtm%2BZggdoGC%2B%2F5pc9mbuS3whm46IEVX%2BJcmdvhSoGcWM9M0aoPsF8MVrZGBP0Huze54udDfJ6JglqsdQP81kmQJPfW4AnQDRBZX5WWSodmOdOmM%2F2uBjNWe6j7lMemtHc3nxP3oR2NRTSYUf0Onh%2BcFccM%2FWxhxChYIhQOdGsBhRoiJC%2BFpEltWkVgCZNFAk8QcxRqooEvNDizUIO6giWzRrQRzDMpVygYJoq0ec0pVQVe3IOXJ4mW1QepTYWY9yVPoqlFQfw4VN%2BlF%2FbG2OnfLkU8IG8GPvN2mkR4immyDCJiQrkR5q8f1xzzMd16mZVUssVsypjnnLmtAsS3V2X%2BheKykegzjcLSfJfpfLuY5ZMKvrGtFT2DX3M%2B8D0ORfTlfkbF6%2Frs5UveGC7b9wa02ACFZ7kOEWHMZfKMBAcLl3KVTjx%2FpbKgwygHJ5PNv7XmMA6GZ8GVWmUawLOJk1g8WQArKyToyv7Dave4iVqispXAlYg6lqcr3QFIMGP0KIv9rNgjBtm20CGLsSkVitY3JAkQRDeirnumx%2F7y3zPIqvbvIrwtOBvRYbjL%2FzMZ37tTfy2U30W%2Fk%2Fs9tmIBOIZTTE4U8YtNTs1qaLhA6bZb3QcoYk7m6%2BekrUfxjf%2BUzev25XYWOI2wCAnUS0ngS162T1yEq5nZPS1dLFue8eiaQkSHJajlHxq9wlvkOAYgitiCyk2CQaX6JAaXLGMi0CLLgFCdCecWgbUbG5kGnY%2BXMzOBx0wI9XhxKsk73ww2%2FVCN0QzXJEyfNvw42ecee2C1yxX1NZdq%2FCHxj4Yr%2BpuP8%2BwRpW7Ri18i8vd8mBBFT7mKTkWS%2BlFqV6u1JKjJoSiC96WTj9un%2F8oTf2PygVkMOzu3EgD0IgOOZbFWEhx005jLhYnQEsSrnq7BBCctBGNZBM8S7zylBBWi659lxICOLTXzk0D4dRr9Jf4wborRmW6WQXrIPUjvh7wylNAWDqDGZbOkQPyeNPeiBBbrcT9lDmJkbg7EiclS3RX39kS9xNnJctiFvCWWZuVRKrYBYW8p0pTuVSv0s%2FcZ7cjoWh4ChiHlxRFQbYKt0etA25vOrVbQj6VDEsOFTSeOp1SAzKYtOb9zae2qxTwjkg6euqOwr5CUOLgp1T%2FbDfp4kHg3m0HW0pDCI7SHQx1gbsjTeEu3DmO0tFn3VVCgWD%2FckVZ9PfipO6uybilnIxaBj2YoLrw2aekPc9Q1fgBLcTawX26p8wvXaKPIzo1KD36gD7mfaDPfJUk24APPYMUhS9FMdkNmcBsApHUDZnO9fmr6qICdNo47AUplcG5ak%2FTuq6z%2FIT71FWat8bleLZTV3On2tghoRd8wiYvY%2Ff4SfMgSdQ9ygM2rpvXogfj7XJ4m%2BTiG%2BST3JZVI7m9%2FggdunY%2FlU6SkIf7guijGxrZStHa4%2BzKxqNW19CY3zdqHc0b5UHV6vCdau44f%2FE5P%2FsS1QKVsy%2BrwODisT6a5OAxweCBa7l5Tv%2F2MzSP%2B9IbRJGWeH%2BJIo5JDwQ%2Bk5RmFY39gQodJ%2FexbOGq5oelSUMlbwGOYEmqSt7hRdzkz35dzkiG6PpBKYtKH3NQyV%2BFSt7i7dKXq5J3hvMBLktMPKjk5bX1oJKX2NiDSv66VfKFb3G5KnmXlyPtup1O0eCZe67TeaJqEDp23aGB5BiydgkgZE8zY6r0IwF0m35xzowATIUU9IeHCvUy%2Fl4cqugSjtV9wocqFkcojvhhl2tnRw74rvojTilX67kzFXwS2JG7CuoS0xXOrdQRM9KD5sNkUiqbvPRpdJuPFD7DvSuerXL0wKdfHtG75xDnm8uSeGDcCgu1IXtI7APkHfXnWI8yzdS7DNqtL5mpCwXdIU%2FpGZ1uO6Nyg2BRy1%2BIwaKQFQ1IkSOFYZiPDYf3ApDCvSvXCFnlj9dZFG5XX%2BKXZDBNbIWe54hZJpA8h3FWardrmQgsY7z4uVpn3dDNR8aKDJ4VSXXXvcs4nrwvP8gTPS%2FJa2HsJKlj1CqeNCXnSYj3jVrlEic31tTGIqXxmGqH9FPlSTlNNtZrOqXRE2bT8EfoNcICvXATc6Kt%2BS2l8jHXNY2euIZ05Yybd1CP5AAGWc9k3OoPXgrZ6%2FX7o%2BPo0JA%2Fs3dz6%2BPOdpjLndkvfSMXoArd0tfkJAikOSWkOAnAUHPekfrjXj3RsBI4%2B4zpliiQyaaOKCOF9CbFs5F6u54%2BIUTFquMORagsVqQjIz7l3dV63F8saF6eQcpZM1bXaaymaGZshWwRoOmHrjaSDigKXLhfXj7nfThJXQPBIFwVX7gclX%2FMZOZELsdjcNy33tQ%2BQG8%2FEvH6hKv8sS2q2BORMW43fsx%2FeGTPy9xmqj8gjMMsxOMBj%2Bnzfx96ouIBTjqzZZBVCmhYcWhjnwEM0srLlVaSaf8obSUPbXtLelLuP7iE3EmnpXuUmGwA6KJKBaArlSoA0LKDdZxvJs23jroY5Cq6SA7hm7O07pSL6rVUIkW4C0vA9dp%2BVBd9JcQl6P%2FHTcC5AbaXDKA9dK9hA4aZ7YbufaDBL%2Ba2%2FRO%2BQE3Y7bw973XQkJkjVhw1zs6V1EaWWQbj55us%2F94ZLwcgk1CHHlh9RMLZE6pY0GBMvQc2r%2BzJ%2B6DzvidZ%2BPIxKVD4tqQMnCCFXCkD0JVG0U9yvNRleSLulJDjpTTfHNB5AfgyEE7PY8B7UPJ8IrfoEemHAuAmqMcMO%2FKH6vMOlBb%2FBqZ97e7QZQ5l2MlJLk1DsT3WG9J78oZcyCo9rAOeTXkS5uk1LEtCYLPsxvtwhTaFzHj6c5DAU9P2mN1cXJ9KssiYzP5cq2wnysU54co16XL2ycB5z9GT6tUX5FJMpj6QeRtfX07dqlnr4yJ5cfDGIXuq%2BWXzMfFYFP5GctIQWqkYLlu6y6xoIpouQGAU1UMLJ7LV6MdN8j%2Ftpinr2gDvI8dNI1ToNcc7hJ7c8W40Tw8%2BOJqYIWKYLYGdeUlqip3wchSydwLBbJeUx%2FDU4gmcXA12bx0CBST6OCq5OWvhcaBhbLZheBtgykaoNozB6tU6pOR5xxafY0IMmAlZ1L5Oa7anwtaCPKatS1fKXzj%2BnOdKzUzb0s1%2BGpTcxwAMIcUZtwZweVAK%2Bhu6dKAd4zux7oYrepwW3SawN669d%2F4%2Fp%2Fd9Q9fzExZa3eWGvPoz%2BaQ%2Fq2BAC%2FCyPVICumoSPULW%2BbNrq0U006F1N7k2FFSuz1scveR%2FvN7WdcvpubfL4Ua7m7tHkwO6%2FXW3ofTggdO0AEcelJV39B%2BkhaEYs7Xf0TlMeNGOFpDln0t4ndf%2FZlOsPilzu8knqs%2FyEPdZ%2BB5qGgFsfWbuiJuuKwCMev0eqWnYPqcLI3jb%2Bmg%2F3befQ9s38Yver8bDHZbFidAHmEnTPauYLOqTSADnbl5%2BwxxCmzfU3yzo1CdBHoXIW7%2F2RyjAvbS2IF8nOoJyck3n8mlNzdUehu0sQpoMhCqVdKQA9DDY8%2Bxu5zj0a2IMoPPcLE8qZwV5XrVsIuBYBsW%2BAAYFds2gtK0K21d%2FbSuITtp8t%2BIvW513HHwLMdCfRtjs2mBZLuYlsOdcLmbheDPxGehQ%2B%2BqN9uWdOgk8fvv2lqm93CPbxzL7X%2BjDB3yH21luH%2BxmNh7OSTPpSXUqzPYtTWd38O%2Bkg7809wr11sNg5oPAOK6H7enoc0c9bBlM6NniwCSXKuuxi5uQOHAnR6iCTGGSxGyxDlkkSbsE%2BOyxfOwK%2BMA222FNrHpNfNDjY71szrkx5TFQkoCsfQHcJWN0RBRIxGSvYfV6aFZzzUbyYYvm86pObJZUe7A6wDtxe0ji%2BWuKm%2BxXf7v6hlp6MI3cNETWLXLtgnMi2Q3pP1kdXatIqIFgUgWho1bGYmwcYCw6F4SWib9KNRKPzbW8R6%2F65zRt1nYf3cqf15sFq8kTdkIey1Nl%2B02XfYFgldEFduO%2FO8I7o9uOG%2Br5TJuGedIUJq3CemifXQOSM8L7leLvOervnqD4%2BQDF1TMWl7RXO72lDouh7j2apg4d%2Br%2FLRmalG6pk7I2UiczC%2B60UITNgUZNmatxz2NjZNSQh801vkhJG5oPcdM%2FQXPLV7by0Omi2IBdVZUMzepsmuNd2AwA16%2BpbssAar%2Bn%2FAQ%3D%3D) ã€‚

![Nacos_æœåŠ¡ç«¯_æ³¨å†Œæµç¨‹å›¾.drawio](../../æ€ç»´å¯¼å›¾/nacos/Nacos_æœåŠ¡ç«¯_æ³¨å†Œæµç¨‹å›¾.drawio.png)

## é•¿è¿æ¥

åœ¨ä¹‹å‰çš„ç¬¬å››ç¯‡ä»¥åŠç¬¬ä¸‰ç¯‡ï¼Œæ¢ç©¶å…¶å®¢æˆ·ç«¯çš„æ³¨å†Œå®ç°çš„æ—¶å€™ï¼Œæ›¾åˆ†æ **NamingClientProxyDelegate** ä»£ç†ç±»ä¸­ **getExecuteClientProxy** å…³äºå½“å‰é€šè®¯æ‰€å®ç°çš„å…·ä½“åè®®ã€‚

~~~ JAVA
private NamingClientProxy getExecuteClientProxy(Instance instance) {
    // ä¸´æ—¶èŠ‚ç‚¹ï¼Œèµ°grpcé•¿è¿æ¥ï¼›æŒä¹…èŠ‚ç‚¹ï¼Œèµ°httpçŸ­è¿æ¥
            return instance.isEphemeral() ? grpcClientProxy : httpClientProxy;
        }
~~~

é‚£ä¹ˆé•¿è¿æ¥ä¸çŸ­è¿æ¥ä¹‹é—´æœ‰ä½•å¼‚åŒå‘¢ï¼Ÿ

é•¿è¿æ¥ï¼Œæ˜¯æŒ‡ä¸€ä¸ªè¿æ¥åªè¦å»ºç«‹ï¼Œå°±å¯ä»¥å‘é€å¤šä¸ªæ•°æ®åŒ…è¿›è¡Œå“åº”ï¼Œå¦‚æœæ²¡æœ‰æ•°æ®åŒ…å‘é€ï¼Œåˆ™éœ€è¦åŒæ–¹å‘é€é“¾è·¯æ£€æµ‹åŒ…ï¼Œå®æ—¶çš„æ£€æµ‹å½“å‰é“¾è·¯çš„çŠ¶æ€ã€‚

Nacos åœ¨ 2.0 ä¹‹åï¼Œç”¨ gPRC é•¿è¿æ¥ä»£æ›¿äº†åŸæ¥çš„ Http çŸ­è¿æ¥è¯·æ±‚ã€‚

**NamingClientProxy** æ¥å£è´Ÿè´£åº•å±‚é€šè®¯ï¼Œè°ƒç”¨æœåŠ¡ç«¯æ¥å£ã€‚æœ‰ä¸‰ä¸ªå®ç°ç±»ï¼š

- **NamingClientProxyDelegate**ï¼šä»£ç†ç±»ï¼Œå¯¹ NacosNamingService ä¸­çš„æ–¹æ³•è¿›è¡Œ**ä»£ç†** ï¼Œæ ¹æ®å®é™…çš„è¯·æ±‚æƒ…å†µé€‰æ‹© http æˆ– gRPC åè®®è¯·æ±‚æœåŠ¡ç«¯ã€‚
- **NamingGrpcClientProxy**ï¼šåº•å±‚é€šè®¯åŸºäº gRPC é•¿è¿æ¥
- **NamingHttpClientProxy**: åº•å±‚é€šè®¯åŸºäºhttpçŸ­è¿æ¥

NamingClientProxyDelegateä¼š**æ ¹æ®instanceå®ä¾‹æ˜¯å¦æ˜¯ä¸´æ—¶èŠ‚ç‚¹è€Œé€‰æ‹©ä¸åŒçš„åè®®**ã€‚

â€‹	ä¸´æ—¶instanceï¼šgRPC

â€‹	æŒä¹…instanceï¼šhttp

## å¥åº·æ£€æŸ¥

â€‹	åœ¨ä¹‹å‰çš„1.xç‰ˆæœ¬ä¸­ä¸´æ—¶å®ä¾‹èµ°Distroåè®®å†…å­˜å­˜å‚¨ï¼Œå®¢æˆ·ç«¯å‘æ³¨å†Œä¸­å¿ƒå‘é€å¿ƒè·³æ¥ç»´æŒè‡ªèº«healthyçŠ¶æ€ï¼ŒæŒä¹…å®ä¾‹èµ°Raftåè®®æŒä¹…åŒ–å­˜å‚¨ï¼ŒæœåŠ¡ç«¯å®šæ—¶ä¸å®¢æˆ·ç«¯å»ºç«‹tcpè¿æ¥åšå¥åº·æ£€æŸ¥ã€‚

â€‹	ä½†æ˜¯2.0ç‰ˆæœ¬ä»¥åæŒä¹…åŒ–å®ä¾‹æ²¡æœ‰ä»€ä¹ˆå˜åŒ–ï¼Œä½†æ˜¯2.0ä¸´æ—¶å®ä¾‹ä¸åœ¨ä½¿ç”¨å¿ƒè·³ï¼Œè€Œæ˜¯é€šè¿‡é•¿è¿æ¥æ˜¯å¦å­˜æ´»æ¥åˆ¤æ–­å®ä¾‹æ˜¯å¦å¥åº·ã€‚

**ConnectionManager**è´Ÿè´£ç®¡ç†æ‰€æœ‰å®¢æˆ·ç«¯çš„é•¿è¿æ¥ã€‚

**æ¯3s**æ£€æµ‹æ‰€æœ‰è¶…è¿‡**20sæ²¡å‘ç”Ÿè¿‡é€šè®¯**çš„å®¢æˆ·ç«¯ï¼Œå‘å®¢æˆ·ç«¯å‘èµ·**ClientDetectionRequestæ¢æµ‹è¯·æ±‚**ï¼Œå¦‚æœå®¢æˆ·ç«¯åœ¨**1så†…æˆåŠŸå“åº”ï¼Œåˆ™æ£€æµ‹é€šè¿‡**ï¼Œå¦åˆ™æ‰§è¡Œunregisteræ–¹æ³•ç§»é™¤Connectionã€‚

**å¦‚æœå®¢æˆ·ç«¯æŒç»­ä¸æœåŠ¡ç«¯é€šè®¯ï¼ŒæœåŠ¡ç«¯æ˜¯ä¸éœ€è¦ä¸»åŠ¨æ¢æ´»çš„**

```java
Map<String, Connection> connections = new ConcurrentHashMap<String, Connection>();
@PostConstruct
public void start() {

    // å¯åŠ¨ä¸å¥åº·è¿æ¥æ’é™¤åŠŸèƒ½.
    RpcScheduledExecutor.COMMON_SERVER_EXECUTOR.scheduleWithFixedDelay(new Runnable() {
        @Override
        public void run() {
            try {

                int totalCount = connections.size();
                Loggers.REMOTE_DIGEST.info("Connection check task start");
                MetricsMonitor.getLongConnectionMonitor().set(totalCount);
                //ç»Ÿè®¡è¿‡æ—¶ï¼ˆ20sï¼‰è¿æ¥
                Set<Map.Entry<String, Connection>> entries = connections.entrySet();
                int currentSdkClientCount = currentSdkClientCount();
                boolean isLoaderClient = loadClient >= 0;
                int currentMaxClient = isLoaderClient ? loadClient : connectionLimitRule.countLimit;
                int expelCount = currentMaxClient < 0 ? 0 : Math.max(currentSdkClientCount - currentMaxClient, 0);

                Loggers.REMOTE_DIGEST
                    .info("Total count ={}, sdkCount={},clusterCount={}, currentLimit={}, toExpelCount={}",
                          totalCount, currentSdkClientCount, (totalCount - currentSdkClientCount),
                          currentMaxClient + (isLoaderClient ? "(loaderCount)" : ""), expelCount);

                List<String> expelClient = new LinkedList<>();

                Map<String, AtomicInteger> expelForIp = new HashMap<>(16);

                //1. calculate expel count  of ip.
                for (Map.Entry<String, Connection> entry : entries) {

                    Connection client = entry.getValue();
                    String appName = client.getMetaInfo().getAppName();
                    String clientIp = client.getMetaInfo().getClientIp();
                    if (client.getMetaInfo().isSdkSource() && !expelForIp.containsKey(clientIp)) {
                        //get limit for current ip.
                        int countLimitOfIp = connectionLimitRule.getCountLimitOfIp(clientIp);
                        if (countLimitOfIp < 0) {
                            int countLimitOfApp = connectionLimitRule.getCountLimitOfApp(appName);
                            countLimitOfIp = countLimitOfApp < 0 ? countLimitOfIp : countLimitOfApp;
                        }
                        if (countLimitOfIp < 0) {
                            countLimitOfIp = connectionLimitRule.getCountLimitPerClientIpDefault();
                        }

                        if (countLimitOfIp >= 0 && connectionForClientIp.containsKey(clientIp)) {
                            AtomicInteger currentCountIp = connectionForClientIp.get(clientIp);
                            if (currentCountIp != null && currentCountIp.get() > countLimitOfIp) {
                                expelForIp.put(clientIp, new AtomicInteger(currentCountIp.get() - countLimitOfIp));
                            }
                        }
                    }
                }

                Loggers.REMOTE_DIGEST
                    .info("Check over limit for ip limit rule, over limit ip count={}", expelForIp.size());

                if (expelForIp.size() > 0) {
                    Loggers.REMOTE_DIGEST.info("Over limit ip expel info, {}", expelForIp);
                }

                Set<String> outDatedConnections = new HashSet<>();
                long now = System.currentTimeMillis();
                //2.get expel connection for ip limit.
                for (Map.Entry<String, Connection> entry : entries) {
                    Connection client = entry.getValue();
                    String clientIp = client.getMetaInfo().getClientIp();
                    AtomicInteger integer = expelForIp.get(clientIp);
                    if (integer != null && integer.intValue() > 0) {
                        integer.decrementAndGet();
                        expelClient.add(client.getMetaInfo().getConnectionId());
                        expelCount--;
                    } else if (now - client.getMetaInfo().getLastActiveTime() >= KEEP_ALIVE_TIME) {
                        outDatedConnections.add(client.getMetaInfo().getConnectionId());
                    }

                }

                //3. if total count is still over limit.
                if (expelCount > 0) {
                    for (Map.Entry<String, Connection> entry : entries) {
                        Connection client = entry.getValue();
                        if (!expelForIp.containsKey(client.getMetaInfo().clientIp) && client.getMetaInfo()
                            .isSdkSource() && expelCount > 0) {
                            expelClient.add(client.getMetaInfo().getConnectionId());
                            expelCount--;
                            outDatedConnections.remove(client.getMetaInfo().getConnectionId());
                        }
                    }
                }

                String serverIp = null;
                String serverPort = null;
                if (StringUtils.isNotBlank(redirectAddress) && redirectAddress.contains(Constants.COLON)) {
                    String[] split = redirectAddress.split(Constants.COLON);
                    serverIp = split[0];
                    serverPort = split[1];
                }

                for (String expelledClientId : expelClient) {
                    try {
                        Connection connection = getConnection(expelledClientId);
                        if (connection != null) {
                            ConnectResetRequest connectResetRequest = new ConnectResetRequest();
                            connectResetRequest.setServerIp(serverIp);
                            connectResetRequest.setServerPort(serverPort);
                            connection.asyncRequest(connectResetRequest, null);
                            Loggers.REMOTE_DIGEST
                                .info("Send connection reset request , connection id = {},recommendServerIp={}, recommendServerPort={}",
                                      expelledClientId, connectResetRequest.getServerIp(),
                                      connectResetRequest.getServerPort());
                        }

                    } catch (ConnectionAlreadyClosedException e) {
                        unregister(expelledClientId);
                    } catch (Exception e) {
                        Loggers.REMOTE_DIGEST.error("Error occurs when expel connection, expelledClientId:{}", expelledClientId, e);
                    }
                }

                //4.client active detection.
                Loggers.REMOTE_DIGEST.info("Out dated connection ,size={}", outDatedConnections.size());
                //å¼‚æ­¥è¯·æ±‚æ‰€æœ‰éœ€è¦æ£€æµ‹çš„è¿æ¥
                if (CollectionUtils.isNotEmpty(outDatedConnections)) {
                    Set<String> successConnections = new HashSet<>();
                    final CountDownLatch latch = new CountDownLatch(outDatedConnections.size());
                    for (String outDateConnectionId : outDatedConnections) {
                        try {
                            Connection connection = getConnection(outDateConnectionId);
                            if (connection != null) {
                                ClientDetectionRequest clientDetectionRequest = new ClientDetectionRequest();
                                connection.asyncRequest(clientDetectionRequest, new RequestCallBack() {
                                    @Override
                                    public Executor getExecutor() {
                                        return null;
                                    }

                                    @Override
                                    public long getTimeout() {
                                        return 1000L;
                                    }

                                    @Override
                                    public void onResponse(Response response) {
                                        latch.countDown();
                                        if (response != null && response.isSuccess()) {
                                            connection.freshActiveTime();
                                            successConnections.add(outDateConnectionId);
                                        }
                                    }

                                    @Override
                                    public void onException(Throwable e) {
                                        latch.countDown();
                                    }
                                });

                                Loggers.REMOTE_DIGEST
                                    .info("[{}]send connection active request ", outDateConnectionId);
                            } else {
                                latch.countDown();
                            }

                        } catch (ConnectionAlreadyClosedException e) {
                            latch.countDown();
                        } catch (Exception e) {
                            Loggers.REMOTE_DIGEST
                                .error("[{}]Error occurs when check client active detection ,error={}",
                                       outDateConnectionId, e);
                            latch.countDown();
                        }
                    }

                    latch.await(3000L, TimeUnit.MILLISECONDS);
                    Loggers.REMOTE_DIGEST
                        .info("Out dated connection check successCount={}", successConnections.size());
					// å¯¹äºæ²¡æœ‰æˆåŠŸå“åº”çš„å®¢æˆ·ç«¯ï¼Œæ‰§è¡Œunregisterç§»å‡º
                    for (String outDateConnectionId : outDatedConnections) {
                        if (!successConnections.contains(outDateConnectionId)) {
                            Loggers.REMOTE_DIGEST
                                .info("[{}]Unregister Out dated connection....", outDateConnectionId);
                            unregister(outDateConnectionId);
                        }
                    }
                }

                //reset loader client

                if (isLoaderClient) {
                    loadClient = -1;
                    redirectAddress = null;
                }

                Loggers.REMOTE_DIGEST.info("Connection check task end");

            } catch (Throwable e) {
                Loggers.REMOTE.error("Error occurs during connection check... ", e);
            }
        }
    }, 1000L, 3000L, TimeUnit.MILLISECONDS);

}

//æ³¨é”€ï¼ˆç§»å‡ºï¼‰è¿æ¥æ–¹æ³•
public synchronized void unregister(String connectionId) {
    Connection remove = this.connections.remove(connectionId);
    if (remove != null) {
        String clientIp = remove.getMetaInfo().clientIp;
        AtomicInteger atomicInteger = connectionForClientIp.get(clientIp);
        if (atomicInteger != null) {
            int count = atomicInteger.decrementAndGet();
            if (count <= 0) {
                connectionForClientIp.remove(clientIp);
            }
        }
        remove.close();
        Loggers.REMOTE_DIGEST.info("[{}]Connection unregistered successfully. ", connectionId);
        clientConnectionEventListenerRegistry.notifyClientDisConnected(remove);
    }
}
```

ç§»é™¤connectionåï¼Œç»§æ‰¿ClientConnectionEventListenerçš„**ConnectionBasedClientManager**ä¼šç§»é™¤Clientï¼Œå‘å¸ƒ**ClientDisconnectEventäº‹ä»¶**ã€‚

```java
@Override
public boolean clientDisconnected(String clientId) {
    Loggers.SRV_LOG.info("Client connection {} disconnect, remove instances and subscribers", clientId);
    ConnectionBasedClient client = clients.remove(clientId);
    if (null == client) {
        return true;
    }
    client.release();
    NotifyCenter.publishEvent(new ClientEvent.ClientDisconnectEvent(client));
    return true;
}
```

ClientDisconnectEventä¼šè§¦å‘å‡ ä¸ªäº‹ä»¶ï¼š

**1ï¼‰Distroåè®®**ï¼šåŒæ­¥ç§»é™¤çš„clientæ•°æ®

**2ï¼‰æ¸…é™¤ä¸¤ä¸ªç´¢å¼•ç¼“å­˜**ï¼šClientServiceIndexesManagerä¸­Serviceä¸å‘å¸ƒClientçš„å…³ç³»ï¼›ServiceStorageä¸­Serviceä¸Instanceçš„å…³ç³»

**3ï¼‰æœåŠ¡è®¢é˜…**ï¼šClientDisconnectEventä¼š**é—´æ¥è§¦å‘ServiceChangedEventäº‹ä»¶**ï¼Œå°†æœåŠ¡å˜æ›´é€šçŸ¥å®¢æˆ·ç«¯ã€‚